% function locationList = estimateAnglePos(locationList, steeringVectors, matchList, freqSignals)
%
% This function estimates the azimuth DOA for each target provided in
% locationList.
% Right now it just gives back a random angle between -0.5 and 0.5 rad
%
% locationList: list containing all targets. Each
% entry is a struct with fields: distance, velocity and angle as
% generated by estimateDVPos().
% steeringVectors: given by the measurements for the sensor array that is
% used.
% matchList: a #ramps-by-#targets matrix, each column representing
% the frequency vector for one matched target in units "bin". It is
% generated by frequencyMatching.
% Entries in matchList correspond to those in locationList, i.e. the first
% column in matchList is the frequency vector for the first target in
% locationList (accessed by locationList(1))
% freqSignals: a #ramps-by-#beams cell array. Each entry contains the
% frequency signals for the particular ramp and beam as given by the
% indices; e.g. freqSignals{1,2} is the vector with the frequency signals
% for the first ramp and the second beam
% returns locationList: locationList updated by an angle estimate for each
% target. Angle in units of rad

function locationList = estimateAnglePos(locationList, steeringVectors, matchList, freqSignals, angs)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Xu %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Use DML method estimate angle
% For one target, now without considering order estimation, later will
% complete with the situation with order estimation;
% For multi-targets, targets are independent, so calculate independently,
% define a cycle by target_idx

if ~isempty(matchList)          % only run the fuction when matchList_All is not empty % will matter in real data
    
    % parameter defination
    ramp_idx = size(matchList, 1);          % No. of ramps, simulated data: 4
    antenna_idx = size(freqSignals, 2);     % No. of antennass, simulated data: 8
    angs_idx = size(angs, 2);               % No. of angs in the scanned range, simulated data:240
    target_idx = size(matchList, 2);        % No. of column in matchList, when considerng order estimation, then this is not the real No. of targets
    
    %% Analyse the min(ang){Tr{pai(A) * R^}}. Then we can get some simpler form min(ang){(-||a'*y||^2)/||a||^2}
    %%%%%% One target and without considering order estimation %%%%%%%%%
    
    % array or matrix defination
    a = zeros(antenna_idx, 1);            % Store one column of steeringvector
    spectrum_of_peak = cell(target_idx, ramp_idx);    % each cell is 1*8
    y = cell(1, target_idx);              % each cell is a matrix for 4 ramps, each column(8*1) is the y for certain target and the column is the transpose of spectrum_of_peak
    mod = zeros(target_idx, ramp_idx);    % for square of a'*y
    ML = zeros(target_idx, angs_idx);     % this ML is for simplied formular, different with original case(calculate trace)
    ML_min = zeros(target_idx, 1);
    angs_index = zeros(target_idx, 1);
    angle_estiamte = zeros(target_idx, 1);
    
    
    for t = 1:target_idx
        for i = 1: angs_idx
            a = steeringVectors(:, i);    % try every angle, i.e. try every column of steeringvector
            
            for j = 1: ramp_idx
                spectrum_of_peak =  match(matchList(:, t), freqSignals, spectrum_of_peak, j, t);  % only pass one column of matchList to find the spectrum
                y{1, t}(:, j) = spectrum_of_peak{t, j};      % transpose spectrum_of_peak to 8*1
                mod(t, j) = - (a' * y{1, t}(:, j))' * (a' * y{1, t}(:, j));    % mod stores only number, which is the square of the vector
                mod(t, j) = mod(t, j) / (a' * a);
            end
            
            % sum over ramp, take the mean value
            for k = 1: ramp_idx
                ML(t, i) = ML(t, i) + mod(t, k);
            end
        end
        
        % find minimum value of ML, store the index
        [ML_min(t, 1), angs_index(t, 1)] = min(ML(t, :));
        % plot(ML(t, :));figure(gcf)
        
        % get estimated angle
        angle_estiamte(t, 1) = angs(angs_index(t, 1));
        
        %%%%%%%%%%%%%%%%%%%%% order estimation %%%%%%%%%%%%%%%%%%%%%%%%%%
        % In case there is a situation that two objects exists with the same
        % velocity and distance. So matchlist will get only one column for them.
        % Hence we need order estimation: Set a ratio number, compare one object
        % pdf(or say likelihood function) and two objects'. If the quotient is larger than the ratio, then
        % it means this is indeed one object, otherwise there are two object, so need
        % add one column with result to locationList.
        
        % The algorithm and simplified ratio test formula is written in the
        % report.
        % But time is not enough to test the ratio threshold value.
        
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        
        % write results into the locationList
        locationList(t).angle = angle_estiamte(t, 1);
        
    end
end
end

% Find the peak spectrum
function spectrum_of_peak =  match(matchList, freqSignals, spectrum_of_peak, m, i)
% m is for different ramps  %i is for different target
 for p = 1:size(freqSignals, 2)     % p is for different antennas, iteration from 1 to 8
        
        % For changing the frequncy stored in matchList to the index in
        % freqSignal
        A=length(freqSignals{m,p}); 
        Freq_L=A./2;
        spectrum_of_peak{i,m}(1,p) = freqSignals{m,p}(ceil(matchList(m, 1) + Freq_L));
        % now can use the row in one cell of spectrum_of_peak to get y, dim is 1*8
end

end

%% Original non-simplified way and for single target

% function locationList = estimateAnglePos(locationList, steeringVectors, matchList, freqSignals, angs)

% % Use DML method estimate angle (for one target) at the begining
% % Now try all angles in variable 'angs' to find one solved minimization problem.
%
% % useful indice
% angs_idx = size(angs, 2);                     % angs is 1 * 241
% antennas_idx = size(steeringVectors, 1);     % steeringVectors is 8 * 241
% ramps_idx = size(matchList, 1);               % matchList is 4 ramps * No. of target
%
% % useful matrice and cells
% ML = zeros(1, angs_idx);  	% stores the candidates of ML
% a = zeros(antennas_idx, 1);   	% one column of steeringVectors
% y = cell(1, ramps_idx); 	% for y, dim is 1*4, each cell is 1*8
% R = cell(1, ramps_idx); 		% for y*y',dim is 1*4
% R_cov = zeros(antennas_idx);
% Pai_Steeringvector = zeros(size(freqSignals, 2));
% spectrum_of_peak = cell(1,ramps_idx);   % 1*4
%
%
%     R_cov = signal(matchList, freqSignals, spectrum_of_peak, y, R, ramps_idx, antennas_idx, R_cov);   % since this is not varying with angle,
%                                                                                         % so calculate first, to reduce the calculation complexity
%
%     for i = 1:angs_idx
%         a = steeringVectors(:, i);
%
%         % calculate A correlated matrix, see paper
%         Pai_Steeringvector = (eye(size(freqSignals, 2))) - (a * pinv(a));
%
%         % store ALL candidates of ML
%         ML(i) = trace(Pai_Steeringvector * R_cov);
%     end
%
%     % find min ML, and store index, i.e. index in angs
%     [ML_min, angs_index] = min(ML);
%     % plot(abs(ML));figure(gcf)

%     % get estimated angle
%     angle_estiamte = angs(angs_index);
%
%     % write results into the locationList; now for one target
%     locationList(1).angle = angle_estiamte;
%
% end


% This is used when calculate auto-correlated matrix for y
% function R_cov = signal(matchList, freqSignals, spectrum_of_peak, y, R, ramps_idx, antennas_idx, target_idx, R_cov)
%
%         for i = 1:target_idx
%             R_cov{1, i}= zeros(antennas_idx);     % Initialization
%             for j = 1:ramps_idx
%             % spectrum_of_peak =  match() find all spectrums of the frequencies
%             % which are stored in the matchList.
%                 spectrum_of_peak =  match(matchList, freqSignals, spectrum_of_peak, j, i);
%                 y{i,j} = (spectrum_of_peak{i,j}).';   % considered only one object here, one cell of y is 8*1
%                 R{i,j} = (y{i,j}) * (y{i,j}');
%             end
%
%             % calculate R^
%             for idx_sum = 1:ramps_idx
%                 R_cov{1, i} = R_cov{1, i} + R{i, idx_sum};
%             end
%             R_cov{1, i} = (R_cov{1, i})/(ramps_idx);
%         end
% end


